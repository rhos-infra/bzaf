"""
Copyright 2019 Vadim Khitrin <me@vkhitrin.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

import bugzilla
import bzaf.version
import requests
import tempfile

from bzaf.api import validator
from bzaf.utils import exceptions
from bzaf.utils import logger
from datetime import datetime
from iteration_utilities import deepflatten

bzaf_logger = logger.subscribe_to_logger()


def get_current_timestamp():
    """
    Get current timestamp

    Returns:
        current_timestamp: A formatted string of current time:
                           <month><day><year><hour><minutes><seconds>
    """
    current_timestamp = datetime.now().strftime("%m%d%Y%H%M%S")
    return current_timestamp


def write_content_to_tempfile(content):
    """
    Write content to temporary file

    Parameters:
        content: Content to write to file

    Returns:
        temp_file: tempfile
    """
    # If we recieve an output that contains a list
    # flatten it to a single list
    if (isinstance(content, list)):
        content = list(deepflatten(content, depth=1))
    # Create temporary file
    temp_file = tempfile.NamedTemporaryFile(suffix='.txt', mode='w+t')
    # Write content to temporary file
    temp_file.writelines(content)
    # Commit changes to file
    temp_file.seek(0)
    return temp_file


def prepare_bzaf_comment(successful, status, resolution):
    """
    Prepares bzaf comment containing the executiong result

    Parameters:
        successful: Whether bzaf spec execution was successful
        status: Bug status to set if verification is successful
        resolution: Bug resolution to if verification is successful

    Returns:
        generated_comment: bzaf comment that will be posted
    """
    generated_comment = []
    # If bzaf spec execution is successful
    if successful:
        generated_comment.append('Spec executed successfully')
        generated_comment.append('Verifying bug as {s} {r}'
                                 .format(s=status, r=resolution))
        generated_comment.append('Verification output is attached to comment')
    # If bzaf spec execution failed
    else:
        generated_comment.append('Failed to verify bug via spec execution')
        generated_comment.append('Verification attempt is attached to comment')
    generated_comment.append('\nGenerated by bzaf {}'
                             .format(bzaf.version.__version__))
    return generated_comment


def upload_bugzilla_attachment(instance, bug, content, is_private, comment,
                               content_type='text/plain'):
    """
    Upload attachment to bugzilla bug

    Parameters:
        instance: Bugzilla Instance (expects Bugzilla object)
        bug: Bugzilla bug ID
        content: Content of bzaf spec execution
        is_private: Whether to set the attachment as private
        comment: Comment to upload (list of strings)
        content_type: Attachment's HTML content type
    """
    # Convert a list of strings into a single string
    comment = "\n".join(comment)
    # Generate temporary file with the bzaf spec execution output
    attach_file = write_content_to_tempfile(content)
    attach_file_name = ('bzaf_auto_verification_output_{}'
                        .format(get_current_timestamp()))
    # Attempt to upload attachment to Bugzilla
    try:
        instance.attachfile(bug, attach_file, attach_file_name,
                            is_private=is_private,
                            comment=comment,
                            content_type=content_type)
    # TODO: Work on proper exceptions
    except Exception as e:
        bzaf_logger.error(e)


def discover_bugzilla_endpoint(bugzilla_url, api_key=None):
    """
    Attempts to discover if a given URL contains an exposed Bugzilla API

    Parameters:
        bugzilla_url - URL of potential Bugzilla
        api_key - API key to use when attempting to connect to Bugzilla API

    Returns:
        bugzilla_instance - Returns bugzilla Bugzilla object
    """
    # Try to connect to bugzilla XMLRPC API endpoint
    try:
        bzaf_logger.debug('Bugzilla API URL: {}'.format(bugzilla_url))
        if api_key:
            bugzilla_instance = bugzilla.Bugzilla(bugzilla_url,
                                                  api_key=api_key)
        else:
            bugzilla_instance = bugzilla.Bugzilla(bugzilla_url)
    except requests.exceptions.ConnectionError as e:
        bzaf_logger.debug("{}".format(e))
        raise exceptions.bzafConnectivityException(bugzilla_url)
    except requests.exceptions.HTTPError as e:
        bzaf_logger.debug("{}".format(e))
        raise exceptions.bzafConnectivityException(bugzilla_url)
    except bugzilla.BugzillaError as e:
        bzaf_logger.debug("{}".format(e))
        raise exceptions.bzafBugzillaAPIError()
    return bugzilla_instance


def authenticate_with_bugzilla_instance(bugzilla_instance,
                                        interactive_login=False):
    """
    Authenticate with Bugzilla API

    If bugzilla_instance was created with API key, interactive login is not
    needed

    Parameters:
        bugzilla_instance: Bugzilla instance defined by
                           discover_bugzilla_endpoint function
        interactive_login: Use interactive login to cache credentials
    """
    # No credentials supplied/cached
    if not bugzilla_instance.logged_in:
        bzaf_logger.warning('No cached credentials are present on host, '
                            'supply API key or use interactive-login')
        # Interactive login - will cache credentials
        if interactive_login:
            try:
                bugzilla_instance.interactive_login()
            except bugzilla.BugzillaError as e:
                raise exceptions.bzafLoginError(e)
        else:
            raise exceptions.bzafNoCredentials()


def fetch_bugs_from_bugzilla(bugzilla_instance,
                             bugs_id_list=None,
                             bugzilla_query=None):
    """
    Attempt to fetch bugs from Bugzilla

    Parameters:
        bugzilla_instance: Bugzilla instance defined by
                           discover_bugzilla_endpoint function
        bug_id_list: Bug IDs supplied from user input
        bugzilla_query: Bugs supplied by a Bugzilla query

    Returns:
        fetched_bugs: List of bugs
    """
    # Fields that will be retrieved from bugzilla API
    fields = [
        "id",
        "status",
        "resolution",
        "product",
        "summary",
        "reporter",
        "assigned_to"
    ]
    # Init bugs list from input or query
    fetched_bugs = []
    if bugs_id_list:
        # Iterate over bugs
        for bug_id in bugs_id_list:
            fetched_bugs.append(bugzilla_instance.getbug
                                (bug_id,
                                 include_fields=fields))
    elif bugzilla_query:
        query = bugzilla_instance.url_to_query(bugzilla_query,
                                               include_fields=fields)
        fetched_bugs = bugzilla_instance.query(query)
    return fetched_bugs


def discover_valid_bugs(bugs, valid_status):
    """
    Iterates over a list of bugs and returns a list of valid bugs

    Parameters:
        bugs - List of bugs retrieved by fetch_bugs_from_bugzilla function
        valid_status - Bug status that is valid during invocation

    Returns:
        valid_bugs: List of valid bugs to attempt to verify
    """
    # Init valid bugs list
    valid_bugs = []
    for bug in bugs:
        # Check if current bug status equals to status user requested
        if bug.status != valid_status:
            bzaf_logger.debug('BZ #{i} status does not '
                              'match {s}'.format(i=bug.id,
                                                 s=valid_status))
        else:
            bzaf_logger.debug('BZ #{} is valid'.format(bug.id))
            valid_bugs.append(bug)

    # Raise an error if no valid bugs are found
    if not valid_bugs:
        raise exceptions.bzafNoValidBugs()
    return valid_bugs


def verify_valid_bugs(valid_bugs, verified_status, verified_resolution,
                      bugzilla_instance, job_env,
                      private_comments_only=False):
    """
    Attempts to verify valid bugs

    Parameters:
        valid_bugs - List of bugs from discover_valid_bugs function
        verified_status - Status to set if bug was verified
        verified_resolution - Resolution to set if bug was verified
        bugzilla_instance: Bugzilla instance defined by
                           discover_bugzilla_endpoint function
        job_env - Job environment to compare to in spec
        private_comments_only - Parse only private comments

    Returns:
        updated_bugs: List of bugs that successfully uploaded attachments to
        verified_bugs: List of bugs that were successfully verified by bzaf
    """
    # Init variables
    verified_bugs = []
    updated_bugs = []
    # Iterate over valid bugs
    for valid_bug in valid_bugs:
        bzaf_found = False
        print('\nQuery bug #{}'.format(valid_bug.id))
        comments = valid_bug.getcomments()
        # Iterate over comments in reverse order (from last to first)
        for comment in reversed(comments):
            if private_comments_only:
                if not comment['is_private']:
                    bzaf_logger.error('Can not parse from non private '
                                      'comment #{}'
                                      .format(comment['count']))
                    continue
            text = comment['text']
            bzaf_logger.debug('Iterrating over comment #{}'
                              .format(comment['count']))
            # security override : skip bz verification if found:
            if 'bzaf_skip' in text and comment["is_private"]:
                break
            # Attempt to validate comment according to BZAF spec
            bzaf_request = validator.validate_bzaf_yaml(text, job_env)
            if bzaf_request:
                print('Valid spec was found')
                bzaf_found = True
                break

        # If valid bzaf spec located in comment, attempt to execute it
        if bzaf_found:
            upload_attachment = False
            # Execute according to bzaf request
            bzaf_execution, bzaf_output = bzaf_request.execute_bzaf_request()
            comment = prepare_bzaf_comment(bzaf_execution, verified_status,
                                           verified_resolution)
            # If executed successfully
            try:
                upload_bugzilla_attachment(bugzilla_instance, valid_bug.id,
                                           bzaf_output, private_comments_only,
                                           comment)
                print('Uploaded attachment to bug')
                updated_bugs.append(updated_bugs)
                upload_attachment = True
            except Exception as e:
                print('Failed to upload attachment, will not attempt to '
                      'update bug status')
                bzaf_logger.error('Failed to update bug with attachment '
                                  '{}'.format(e))
            if upload_attachment:
                if bzaf_execution:
                    update = (bugzilla_instance.build_update
                              (status=verified_status,
                               resolution=verified_resolution))
                    try:
                        bugzilla_instance.update_bugs(valid_bug.id, update)
                        print('Verified bug')
                        # Update bug properties
                        valid_bug.refresh()
                        verified_bugs.append(valid_bug)
                    except Exception as e:
                        bzaf_logger.error('Failed to update bug #{b}\n{e}'
                                          .format(b=valid_bug.id, e=e))
                        print('Failed to verify bug')
        else:
            print('No valid spec was found')
    return updated_bugs, verified_bugs
